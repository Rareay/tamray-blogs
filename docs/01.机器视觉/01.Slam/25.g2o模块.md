---
title: g2o模块
date: 2020-08-28 15:49:54
permalink: /pages/197aa0/
categories: 
  - 机器视觉
  - Slam
tags: 
  - slam
  - 图优化
  - 最小二乘
---


## 1简介
g2o 是一个基于图优化的库，是为了更直观的体现出优化模型的形态，看出各个优化变量和误差项的关联；图优化由顶点和边构成，其中，`顶点`表示`优化变量`，`边`表示`误差项`，于是，对于任意一个非线性最小二乘问题，我们可以构建与之对应的的一个包含顶点和边的`图`；

## 2 安装
先安装以下库：
```shell
sudo apt install qt5-qmake qt5-default libqglviewer-dev-qt5 libsuitesparse-dev libcxsparse3 libcholmod3
```
然后下载源码（[地址](https://github.com/RainerKuemmerle/g2o)），用 cmake 安装，默认安装在 `/usr/local/lib` 下，

## 3 使用实例
### 3.1 案例1

- 目标:
  
  拟合以下曲线：
     $$ y = exp(ax^2 + bx + c) + w $$
  在这个方程中，$x$ 为一批输入值，$y$ 为一批观测值，$w$ 为随机噪声，而参数 $a$、$b$、$c$ 是未知，我们的目标就是优化它从而拟合该曲线方程；
	
- 分析

  我们可以将此问题转换为一个最小二乘问题：
  $$min \frac{1}{2} \sum_{i=1}^{N} || y_i  - exp(ax_i^2 + bx_i + c)||^2 $$
  在这个最小二乘问题中，我们定义误差为：
  $$e_i = y_i - exp(ax_i^2 + bx_i + c)$$
  然后求出误差对参数的偏导：
  $$ \frac{\partial{e_i}}{\partial{a}} =  -x_i^2exp(ax_i^2 + bx_i + c) $$
  $$ \frac{\partial{e_i}}{\partial{b}} =  -x_iexp(ax_i^2 + bx_i + c) $$
  $$ \frac{\partial{e_i}}{\partial{c}} =  -exp(ax_i^2 + bx_i + c) $$
  于是，$J = \begin{bmatrix}  \frac{\partial{e_i}}{\partial{a}},  \frac{\partial{e_i}}{\partial{a}},  \frac{\partial{e_i}}{\partial{a}} \end{bmatrix}^T$，高斯牛顿的增量方程为：
  $$ (\sum_{i=1}^{N} J_i J_i^T) \Delta a = \sum_{i=1}^{N} -J_i e_i $$
  其中，$\Delta a$ 就是需要迭代产生的参数更新量；

- 模型
```mermaid
graph LR
x([输入值 x])
y([预测值 y])
a([初始化顶点 a])
f1[1. 更新误差 2. 更新雅可比矩阵]
f2((1. 更新顶点))
x -.-> f1
y -.-> f1
a -.-> f2
f1 -- 更新值 --> f2
f2 -- 新顶点 --> f1
```
- 代码
:::details
```cpp
#include <iostream>
#include <g2o/core/g2o_core_api.h>
#include <g2o/core/base_vertex.h>
#include <g2o/core/base_unary_edge.h>
#include <g2o/core/block_solver.h>
#include <g2o/core/optimization_algorithm_levenberg.h>
#include <g2o/core/optimization_algorithm_gauss_newton.h>
#include <g2o/core/optimization_algorithm_dogleg.h>
#include <g2o/solvers/dense/linear_solver_dense.h>
#include <Eigen/Core>
#include <opencv2/core/core.hpp>
#include <cmath>
#include <chrono>

// 顶点模型
class CurveFittingVertex : public g2o::BaseVertex<3, Eigen::Vector3d> { // 采用顶点模板，并设置维度、类型
public:
    EIGEN_MAKE_ALIGNED_OPERATOR_NEW

    // 重置顶点
    virtual void setToOriginImpl() override {
        _estimate << 0, 0, 0;
    }

    // 更新顶点
    virtual void oplusImpl(const double *update) override {
        _estimate += Eigen::Vector3d(update);
    }

    virtual bool read(std::istream &in) {}
    virtual bool write(std::ostream &out) const {}
};

// 误差模型
class CurveFittingEdge : public g2o::BaseUnaryEdge<1, double, CurveFittingVertex> {
public:
    EIGEN_MAKE_ALIGNED_OPERATOR_NEW

    CurveFittingEdge(double x) : BaseUnaryEdge(), _x(x) {}

    // 更新误差
    virtual void computeError() override {
        const CurveFittingVertex *v = static_cast<const CurveFittingVertex *> (_vertices[0]);
        const Eigen::Vector3d abc = v->estimate();
        _error(0, 0) = _measurement - std::exp(abc(0,0)*_x*_x + abc(1, 0)*_x + abc(2, 0));
    }

    // 更新雅可比
    virtual void linearizeOplus() override {
        const CurveFittingVertex *v = static_cast<const CurveFittingVertex *> (_vertices[0]);
        const Eigen::Vector3d abc = v->estimate();
        double y = exp(abc[0]*_x*_x + abc[1]*_x + abc[2]);
        _jacobianOplusXi[0] = -_x * _x * y;
        _jacobianOplusXi[1] = -_x * y;
        _jacobianOplusXi[2] = -y;
    }

    virtual bool read(std::istream &in) {}
    virtual bool write(std::ostream &out) const {}

public:
    double _x;
};


int main()
{
    double ar = 3.0, br = 4.0, cr = 1.0; // 真实参数
    double ae = 1.0, be = 3.0, ce = 2.0; // 预测参数
    int N = 100; // 数据个数
    double w_sigma = 1.0; // 数据的噪声
    double inv_sigma = 1.0 / w_sigma; // w_sigma^-1

    // 生成数据
    cv::RNG rng;
    std::vector<double> x_data, y_data;
    for (int i = 0; i < N; i++) {
        double x = i / 100.0;
        x_data.push_back(x);
        y_data.push_back(exp(ar*x*x + br*x + cr) 
                         + rng.gaussian(w_sigma*w_sigma));
    }


    // 设定g2o
    typedef g2o::BlockSolver<g2o::BlockSolverTraits<3, 1>> BlockSolverType; // 顶点类型
    typedef g2o::LinearSolverDense<BlockSolverType::PoseMatrixType> LinearSolverType; // 边类型

    auto solver = new g2o::OptimizationAlgorithmGaussNewton( // 求解器
        g2o::make_unique<BlockSolverType>(g2o::make_unique<LinearSolverType>()));
    
    g2o::SparseOptimizer optimizer; // 图模型
    optimizer.setAlgorithm(solver); //   设置求解器
    optimizer.setVerbose(true);     //   打开调试输出

    // 增加顶点
    CurveFittingVertex *v = new CurveFittingVertex();
    v->setEstimate(Eigen::Vector3d(ae, be, ce)); // 待优化的参数设为顶点
    v->setId(0);
    optimizer.addVertex(v);

    // 增加边
    for (int i = 0; i < N; i++) {
        CurveFittingEdge * edge = new CurveFittingEdge(x_data[i]); // 输入值
        edge->setId(i);
        edge->setVertex(0, v); // 顶点
        edge->setMeasurement(y_data[i]); // 观测值
        edge->setInformation(Eigen::Matrix<double, 1, 1>::Identity() * inv_sigma);
        optimizer.addEdge(edge);
    }

    optimizer.initializeOptimization();
    optimizer.optimize(10);

    Eigen::Vector3d abc_estimate = v->estimate();
    std::cout << abc_estimate.transpose() << std::endl;

    return 0;
}
```
:::