---
title: Opencv_cplus
date: 2020-08-28 15:49:39
permalink: /pages/220ed1/
categories: 
  - 机器视觉
  - Opencv
tags: 
  - opencv
---
# Opencv(c++)笔记


## 1 图片格式转换
以下代码为Mat、QImage、QPixmap图片格式之间的转换函数：
```c
#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
 
#include <imgproc/types_c.h>
#include <QtGui/QImage>
#include <QtWidgets/QFileDialog>
 
cv::Mat QImage2cvMat(QImage image);
cv::Mat QPixmapcvMat(QPixmap image);
 
QImage cvMat2QImage(const cv::Mat& mat);
QPixmap cvMat2QPixmap(const cv::Mat& mat);
 
QImage QPixmapQImage(QPixmap image);
QPixmap QImageQPixmap(QImage image);
```
```c
#include "ImaRormConv.h"
 
cv::Mat QImage2cvMat(QImage image)
{
    cv::Mat mat;
    switch(image.format())
    {
    case QImage::Format_ARGB32:
    case QImage::Format_RGB32:
    case QImage::Format_ARGB32_Premultiplied:
        mat = cv::Mat(image.height(), image.width(), CV_8UC4, (void*)image.constBits(), image.bytesPerLine());
        break;
    case QImage::Format_RGB888:
        mat = cv::Mat(image.height(), image.width(), CV_8UC3, (void*)image.constBits(), image.bytesPerLine());
        cv::cvtColor(mat, mat, CV_BGR2RGB);
        break;
    case QImage::Format_Indexed8:
        mat = cv::Mat(image.height(), image.width(), CV_8UC1, (void*)image.constBits(), image.bytesPerLine());
        break;
    }
    return mat;
}
 
cv::Mat QPixmapcvMat(QPixmap image)
{
    QImage img = image.toImage();
    cv::Mat mat = QImage2cvMat(img);
    return mat;
}
 
QImage cvMat2QImage(const cv::Mat& mat)
{
    // 8-bits unsigned, NO. OF CHANNELS = 1
    if(mat.type() == CV_8UC1)
    {
        QImage image(mat.cols, mat.rows, QImage::Format_Indexed8);
        // Set the color table (used to translate colour indexes to qRgb values)
        image.setColorCount(256);
        for(int i = 0; i < 256; i++)
        {
            image.setColor(i, qRgb(i, i, i));
        }
        // Copy input Mat
        uchar *pSrc = mat.data;
        for(int row = 0; row < mat.rows; row ++)
        {
            uchar *pDest = image.scanLine(row);
            memcpy(pDest, pSrc, mat.cols);
            pSrc += mat.step;
        }
        return image;
    }
    // 8-bits unsigned, NO. OF CHANNELS = 3
    else if(mat.type() == CV_8UC3)
    {
        // Copy input Mat
        const uchar *pSrc = (const uchar*)mat.data;
        // Create QImage with same dimensions as input Mat
        QImage image(pSrc, mat.cols, mat.rows, mat.step, QImage::Format_RGB888);
        return image.rgbSwapped();
    }
    else if(mat.type() == CV_8UC4)
    {
        // Copy input Mat
        const uchar *pSrc = (const uchar*)mat.data;
        // Create QImage with same dimensions as input Mat
        QImage image(pSrc, mat.cols, mat.rows, mat.step, QImage::Format_ARGB32);
        return image.copy();
    }
    else
    {
        return QImage();
    }
}
QPixmap cvMat2QPixmap(const cv::Mat& mat)
{
    QImage img = cvMat2QImage(mat);
    QPixmap pix = QPixmap::fromImage(img);
    return pix;
}
 
QImage QPixmapQImage(QPixmap image)
{
    QImage img = image.toImage();
    return img;
}
 
QPixmap QImageQPixmap(QImage image)
{
    QPixmap pix = QPixmap::fromImage(image);
    return pix;
}
```
 
## 2 png格式转换为Mat
其它图片转换成Mat格式时默认是BGR格式，有3通道，但png格式的图片包含透明度信息，转换为Mat格式需要有4个通道，即RGBA格式，转换代码：
```c
    cv::Mat mat = ...;
    cv::Mat mat_RGBA;
    cv::cvtColor(mat, mat_RGBA, cv::COLOR_BGRA2RGBA);
```
## 3 读写Mat格式的数据
```c
    cv::Mat mat = ...;
    mat.at<cv::Vec3b>(0, 3)[3] = 0;
	/*
		其中：
		Vec3b：表示mat的向量格式，也就是读写的格式，这里表示一个像素有3个byte；
		（0，3）：表示像素的坐标，0是y轴方向，3是x轴方向；
		[3]：表示该像素的哪个通道；
	*/
    std::cout << mat.rows << std::endl;//行数
    std::cout << mat.cols << std::endl;//列数
    std::cout << mat.channals() << std::endl;//通道数
```
遍历一个Mat的数据提供两种函数，at 和 prt，后者的效率更高：
```c
    int i;
    for (int m = 0; m < mat.cols; m++) {
        for (int n = 0; n < mat.rows; n++) {
            i = mat_RGB.at<cv::Vec3b>(n, m)[0];
            i = mat_RGB.at<cv::Vec3b>(n, m)[1];
            i = mat_RGB.at<cv::Vec3b>(n, m)[2];
            i = mat_RGB.at<cv::Vec3b>(n, m)[3];
			// i = img.at<uchar>(n, m) // 如果是灰度图（单通道）
        }
    }
```
```c
    for (int i =0; i < img.rows; ++i) {
        const int * ptr = img.ptr<int>(i);
        for (int j = 0; j < img.cols * img.channels(); ++j) {
            int data = ptr[j];
        }
    }
```
查看Mat数据还有一个更方法，就是vs里面的image watch插件，大概1.4M。在调试的时候，点击变量那一栏的放大镜，可以查看Mat对应的图像，也可以放大图像看每一个像素的值；

## 4 图片0`~`1和0`~`255的转换
```c
    // 0~255 -> 0~1
    img.convertTo(img, CV_32F, 1.0/255);
 
    // 0~1 -> 0~255
    color.convertTo(color, CV_8U, 255);
```
## 5 Mat和vector互换
```c
/***************** Mat转vector **********************/
template<typename _Tp>
vector<_Tp> convertMat2Vector(const Mat &mat)
{
    return (vector<_Tp>)(mat.reshape(1, 1));//通道数不变，按行转为一行
}
 
/****************** vector转Mat *********************/
template<typename _Tp>
cv::Mat convertVector2Mat(vector<_Tp> v, int channels, int rows)
{
    cv::Mat mat = cv::Mat(v);//将vector变成单列的mat
    cv::Mat dest = mat.reshape(channels, rows).clone();//channels是通道数，rows是行数，这里的.clone是防止下面的return出错
    return dest;
}
```
对std::vector进行片段截取操作
```c
#include <iostream>
#include <vector>
int main() {
    std::vector<int> vector{1,2,3,4,5,6,7,8,9};
    std::cout << "vectoor: ";
    for(auto el : vector) {
        std::cout << el << " ";
    }
    //截取前4个数
    std::vector<int>::const_iterator first1 = vector.begin();
    std::vector<int>::const_iterator last1  = vector.begin() + 4;
    std::vector<int> cut1_vector(first1, last1);
    std::cout << "\ncut1_vector: ";
    for(auto el : cut1_vector) {
        std::cout << el << " ";
    }
    //截取后4个数
    std::vector<int>::const_iterator first2 = vector.end() - 4;
    std::vector<int>::const_iterator last2  = vector.end();
    std::vector<int> cut2_vector(first2, last2);
    std::cout << "\ncut2_vector: ";
    for(auto el : cut2_vector) {
        std::cout << el << " ";
    }
    std::cout << "\n";
}
```
 
## 6 改变Mat尺寸
```c
    // img1是输入图像，img2是输出图像，后面那个是尺寸
    cv::resize(img1, imgc2, cv::Size(500,311));
```
 
## 7 线性融合两张图片
```c
    // img1和img2是准备拼合的图像，alpha是比例，0～1之间，dst是输出图像
    cv::addWeighted(img1, alpha, img2, (1-alpha), 0.0, dst);
```
## 8 opencv 数据类型及相互转换
[参考这里](https://blog.csdn.net/guojunxiu/article/details/83794676)
### 8.1 获取Mat的类型
```c
myMat = imread("C:\someimage.jpg");
int type = myMat.type();
```
返回的类型是个数字，数字的含义可以在下面表格中查找：

|-|C1|C2|C3|C4 |C5|C6|C7 |C8|
|--|--|--|--|--|--|--|--|--|
|CV_8U|     0     |8|     16|     24|     32|     40|     48|     56|
|CV_8S|     1     |9|     17|     25|     33|     41|     49|     57|
|CV_16U|     2     |10|     18|     26|     34|     42|     50|     58|
|CV_16S|     3     |11|     19|     27|     35|     43|     51|     59|
|CV_32S|     4     |12|     20|     28|     36|     44|     52|     60|
|CV_32F|     5     |13|     21|     29|     37|     45|     53|     61|
|CV_64F|6     |14|     22|     30|     38|     46|     54|     62|

C1～C8是通道数，CV_8U ～ CV_64F是图像的数据格式；
### 8.2 颜色空间的转换
```c
//将RGB格式的图像转换成BGR格式
cvtColor(RGB_image, BGR_image, COLOR_RGB2BGR);
//将BGR格式的图像转换成灰度图
cvtColor(BGR_imgage, gray_image, COLOR_BGR2GRAY);
//将BGR格式的图像转换为BGRA
cvtColor(BGR_imgage, gray_image, COLOR_BGR2BGRA);
```
- HSV六棱锥
H参数表示色彩信息，即所处的光谱颜色的位置，用一角度量来表示；红绿蓝间隔隔120度，互补色分别相差180度；
S纯度为一比例值，范围从0到1，它表示成所选颜色的纯度和该颜色最大的纯度之间的比率，S=0时，只有灰度；
V表示色彩的明亮程度，范围从0到1；有一点要注意：它和光强度之间并没有直接的联系。

<img src="/pic/020.png" alt="pic" width="200"/>
<img src="/pic/019.png" alt="pic" width="200"/>

<img src="/pic/018.png" alt="pic" width="200"/>


### 8.3 数据格式的转换
```c
//将[0,1]范围内的浮点表示的图像转换成8bit整数表示的图像
float_image.convertTo(integer_image, CV_8U, 255.0);
 
convertTo函数定义如下：
/** @brief Converts an array to another data type with optional scaling.
 
    The method converts source pixel values to the target data type. saturate_cast\<\> is applied at
    the end to avoid possible overflows:
 
    \f[m(x,y) = saturate \_ cast<rType>( \alpha (*this)(x,y) +  \beta )\f]
    @param m output matrix; if it does not have a proper size or type before the operation, it is
    reallocated.
    @param rtype desired output matrix type or, rather, the depth since the number of channels are the
    same as the input has; if rtype is negative, the output matrix will have the same type as the input.
    @param alpha optional scale factor.
    @param beta optional delta added to the scaled values.
     */
    void convertTo( OutputArray m, int rtype, double alpha=1, double beta=0 ) const;
 
```
## 9 单通道转换为多通道
```c
// 把传入的单通道灰度图转换为3通道RGB
cv::Mat convertTo3Channels(const cv::Mat& binImg)
{
    cv::Mat three_channel = cv::Mat::zeros(binImg.rows,binImg.cols,CV_8UC3);
    std::vector<cv::Mat> channels;
    for (int i=0;i<3;i++)
    {
        channels.push_back(binImg);
    }
    merge(channels,three_channel);
    return three_channel;
}
```
## 10 图像均值、标准差
```c
    cv::Mat src;// 原始图像
    cv::Mat gray;//原始图对应的灰度图
    cv::Mat mat_mean;//均值
    cv::Mat mat_stddev;//标准差
    cv::Mat src = cv::imread("路径", 1); // 参数1表示以原图像格式读取，0表示以灰度图格式读取
    cv::cvtColor(src, gray, cv::CV_BGR2GRAY);
    cv::meanStdDev(gray, mat_mean, mat_stddev);

    double m, s;
    m = mat_mean.at<double>(0, 0); // 均值
    s = mat_stddev.at<double>(0, 0); // 标准差
```
## 11 二值化
函数原型：double threshold( InputArray src,OutputArray dst,double threshold,double maxval,int type );
参数说明：
```c
src：原始数组，可以是Mat类型。
dst：输出数组，必须与 src 的类型一致。
threshold：阈值
maxval：使用 CV_THRESH_BINARY 和 CV_THRESH_BINARY_INV 的最大值。
type：阈值类型
	CV_THRESH_BINARY:如果 src(x,y)>threshold ,dst(x,y) = max_value; 否则,dst（x,y）=0;
	CV_THRESH_BINARY_INV:如果 src(x,y)>threshold,dst(x,y) = 0; 否则,dst(x,y) = max_value.
	CV_THRESH_TRUNC:如果 src(x,y)>threshold，dst(x,y) = max_value; 否则dst(x,y) = src(x,y).
	CV_THRESH_TOZERO:如果src(x,y)>threshold，dst(x,y) = src(x,y) ; 否则 dst(x,y) = 0。
	CV_THRESH_TOZERO_INV:如果 src(x,y)>threshold，dst(x,y) = 0 ; 否则dst(x,y) = src(x,y).
```
例：
```c
// 表示像素值大于100的都变成255（白）
cv::threshold(input, output, 100, 255, CV_THRESH_BINARY);
```

## 12 寻找外轮廓
```c
  cv::cvtColor(img, img, CV_BGR2GRAY);
    std::vector<std::vector<cv::Point>> contours;
    std::vector<cv::Vec4i> hierarchy;
    cv::findContours(img, contours, hierarchy, cv::RETR_EXTERNAL, CV_CHAIN_APPROX_NONE, cv::Point());
    cv::Mat imageContours = cv::Mat::zeros(img.size(), CV_8UC1);
    cv::drawContours(imageContours, contours, -1, cv::Scalar(255), -1, 8, hierarchy);
    img = imageContours.clone();
```
findContours函数可以参考[链接](https://blog.csdn.net/root_clive/article/details/91376256)
## 13 创建Mat图像
```c
//创建Mat图像（像素值自定义）
    Mat MM(5, 5, CV_8UC1, Scalar(128,0,0));// 参数(int rows, int cols, int type, const Scalar& s)
    cout << "MM = " << endl << " " << MM << endl;
 
    //创建Mat图像（像素值205）
    Mat MC;
    MC.create(5, 5, CV_8UC1);
    cout << "MC = "<< endl << " "  << MC << endl;
 
    //创建Mat图像（像素值单位矩阵）
    Mat E = Mat::eye(5, 5, CV_8UC1);
    cout << "E = " << endl << " " << E << endl;
 
    //创建Mat图像（像素值全1矩阵）
    Mat O = Mat::ones(5, 5, CV_32FC1);
    cout << "O = " << endl << " " << O << endl;
 
    //创建Mat图像（像素值全0矩阵）
    Mat Z = Mat::zeros(5, 5, CV_64FC1);
    cout << "Z = " << endl << " " << Z << endl;

```
## 14 读视频、写视频
读视频：
```c
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"

void main()
{
	namedWindow("Example2", WINDOW_AUTOSIZE);
	cv::VideoCapture cap;
	cap.open("H:\\vs2017\\opencv_learning\\ConsoleApplication1\\video.mp4");
	if(!cap.isOpened())
	    return 0;
	//int width = cap.get(CV_CAP_PROP_FRAME_WIDTH);  //帧宽度
	//int height = cap.get(CV_CAP_PROP_FRAME_HEIGHT); //帧高度
	//int frameRate = cap.get(CV_CAP_PROP_FPS);  //每秒的帧数
	//int totalFrames = cap.get(CV_CAP_PROP_FRAME_COUNT); //总帧数
	cv::Mat frame;
	while (1) {
		cap >> frame;
		if (frame.empty()) break;
		cv::imshow("Exameple2",frame);
		if (cv::waitKey(33) >= 0) break;
	}
	cap.release();
}
```
写视频：
```c
void main()
{
    std::string ori_path = "C:/Users/Administrator/Desktop/3.mp4";
    std::string cur_path = "C:/Users/Administrator/Desktop/5.mp4";

    cv::VideoCapture cap(ori_path);

    int width = cap.get(CV_CAP_PROP_FRAME_WIDTH);  //帧宽度
    int height = cap.get(CV_CAP_PROP_FRAME_HEIGHT); //帧高度
    int frameRate = cap.get(CV_CAP_PROP_FPS);  // 每秒的帧数

	// 读取 mp4 格式的视频
    cv::VideoWriter new_cap(cur_path, CV_FOURCC('D', 'I', 'V', 'X'), frameRate,
                            cv::Size(width, height), true);
    cv::Mat frame;
    cv::namedWindow("CXK", CV_WINDOW_AUTOSIZE);
    while (1) {
        cap >> frame;
        if (frame.empty()) break;
        new_cap.write(frame); // 写视频
        cv::imshow("Exameple2",frame);
        if (cv::waitKey(1) >= 0) break;
    }
    cap.release();
    new_cap.release();
}
```
## 15 从多通道中分离单通道
```c
cv::Mat img = ...;
std::vector<cv::Mat> channals[0]);
cv::split(img, channals);
cv::imshow("通道0", channals[0]);
cv::imshow("通道1", channals[1]);
cv::imshow("通道2", channals[2]);
```

## 16 图像分割
用于分割出图像中某一范围内的像素；
原型：void inRange(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)
参数：
```c
src：输入图像，CV2常用Mat类型；
lowerb：范围下限，单通道scalar一个值就行，彩图3通道scalar三个值，如 cv::Scalar(100, 110, 120);
upperb：范围上限，同上；
dst：输出图像，尺寸与src一致，类型是CV_8U，但没有指定通道数。

// 在范围之内的像素输出为255，否则为0；
```

## 17 颜色直方图 + 相似度计算
为了统计图片中各颜色的像素数量可以使用 opencv 自带的函数 cv::calcHist ，可以得到对应的直方图，然后可以利用直方图来计算两张图的相似度，对应的函数 cv::compareHist；在统计直方图之前，最好将图片转换成HSV格式的，统计 H（颜色）、S （程度）两个通道的值，忽略 V（明暗）；
cv::calcHist 函数原型：
```c
void calcHist(const Mat* arrays, 	// 将要统计的图像数组
              int narrays, 						// 图像个数
              const int* channels, 			// 统计哪几个通道
              InputArray mask,				// 可选的掩模，没有特殊需求就填 cv::Mat()
              OutputArray hist, 			// 输出直方图
              int dims, 							// 
              const int* histSize, 				// 把对应通道的对应范围分成多少份来统计
              const float** ranges, 		// 统计的范围
              bool uniform=true, 			
              bool accumulate=false )	
```
cv::compareHist 函数原型：
```c
double cv::compareHist (InputArray H1, // 直方图1
										InputArray H2, // 直方图2
										int method ) // 计算方法
// 有 4 种计算方法：
// 0--相关系数，取值[-1,1]，值越大相关性越好，说明越相似。
// 1--卡方，值越小越相似
// 2--直方图相交，越是相似的图，这个值越大
// 3--Bhattacharyya距离，越小越好
```
例：
```c
    // 两张准备对比的图
    cv::Mat img1 = cv::imread("~/0.jpg", 1);
    cv::Mat img2 = cv::imread("~/1.jpg", 1);
    cv::imshow("1", img1);
    cv::imshow("2", img2);
    cv::Mat hsv_img1, hsv_img2;
    cv::cvtColor(img1, hsv_img1, cv::COLOR_RGB2HSV); // 把格式转换为HSV
    cv::cvtColor(img2, hsv_img2, cv::COLOR_RGB2HSV);
    int channals[] = {0, 1}; // 将要统计的通道（这里是0、1两个通道）
    float h_range[] = {0, 256};
    float s_range[] = {0, 180};
    const float * ranges[] = {h_range, s_range}; // 将要统计这个范围内的像素
    int histSize[] = {50, 50}; // 把该范围分成多少份做统计
    cv::MatND nd_img1;  // 用于存放直方图数据
    cv::MatND nd_img2;
	// 统计出直方图
    cv::calcHist(&hsv_img1, 1, channals, cv::Mat(), nd_img1, 2,
                 histSize, ranges, true, false); 
	 // 归一化
    cv::normalize(nd_img1, nd_img1, 0, 1, cv::NORM_MINMAX, -1, cv::Mat());
    cv::calcHist(&hsv_img2, 1, channals, cv::Mat(), nd_img2, 2,
                 histSize, ranges, true, false);
    cv::normalize(nd_img2, nd_img2, 0, 1, cv::NORM_MINMAX, -1, cv::Mat());
    for (int i = 0; i < 4; i++) { // 有4种计算方法
        int compare_method = i;
        double value1 = cv::compareHist(nd_img1, nd_img1, compare_method);
        double value2 = cv::compareHist(nd_img1, nd_img2, compare_method);
        std::cout << "value1: " << value1 << "   value2: " << value2 << std::endl;
    }
```

## 18 SURF 特征查找、匹配
参考[这里](https://blog.csdn.net/qq_41204464/article/details/90657742)，由于opencv版本不同，新版本采用本篇文章的代码即可使用；
找出特征点：
```cpp
#include <iostream>
#include <opencv2/opencv.hpp>
#include <opencv2/xfeatures2d.hpp>

int main()
{
	cv::Mat IMG1 = cv::imread("0.jpg", 1);
    img1.convertTo(img1, CV_8U);
	cv::Ptr<cv::xfeatures2d::SURF> detector = cv::xfeatures2d::SURF::create(150); // 数字越大，找出的特征点越少，越准确
    std::vector<cv::KeyPoint> keypoints1;
    detector->detect(img1, keypoints1, cv::Mat());
    cv::drawKeypoints(IMG1, keypoints1, IMG1, cv::Scalar::all(-1),
    cv::imshow("1", IMG1);

}
```
对比两张图的特征点：

```cpp
#include <iostream>
#include <opencv2/opencv.hpp>
#include <opencv2/xfeatures2d.hpp>

void main()
{
    cv::Mat IMG1 = cv::imread("0.jpg", 1);
    cv::Mat IMG2 = cv::imread("1.jpg", 1);
    cv::Mat img1 = IMG1.clone();
    cv::Mat img2 = IMG2.clone();
    img1.convertTo(img1, CV_8U); // 转换成 CV_8U
    img2.convertTo(img2, CV_8U); // 转换成 CV_8U

    cv::Ptr<cv::xfeatures2d::SURF> detector = cv::xfeatures2d::SURF::create(200);//数字越大，特征点越少
    std::vector<cv::KeyPoint> keypoints1, keypoints2;
    detector->detect(img1, keypoints1, cv::Mat());//找出特征点
    detector->detect(img2, keypoints2, cv::Mat());
    //cv::drawKeypoints(IMG1, keypoints1, IMG1, cv::Scalar::all(-1), // 把特征点绘制在原图上
    //               cv::DrawMatchesFlags::DEFAULT);
    //cv::drawKeypoints(IMG2, keypoints2, IMG2, cv::Scalar::all(-1),
    //              cv::DrawMatchesFlags::DEFAULT);
    //cv::imshow("1", IMG1);
    //cv::imshow("2", IMG2);

    cv::Ptr<cv::xfeatures2d::SurfDescriptorExtractor> surfDesc = cv::xfeatures2d::SurfDescriptorExtractor::create();
    surfDesc->compute(img1, keypoints1, img1);//特征点描述
    surfDesc->compute(img2, keypoints2, img2);

    cv::Ptr<cv::FlannBasedMatcher> matcher = cv::FlannBasedMatcher::create();
    std::vector<cv::DMatch> matchePoints;
    matcher->match(img1, img2, matchePoints, cv::Mat());//找出两幅图中匹配的点

    cv::Mat img_match;
    cv::drawMatches(IMG1, keypoints1, IMG2, keypoints2, matchePoints, img_match);//拼接两幅图，连接特征点
    cv::imshow("3", img_match);
}
```

<img src='/pic/001.jpg' width='600'/>

过滤掉匹配误差大的点：
```cpp
#include <iostream>
#include <opencv2/opencv.hpp>
#include <opencv2/xfeatures2d.hpp>

int main()
{
    cv::Mat IMG1 = cv::imread("/home/tianru/temp/pic/_39.jpg", 1);
    cv::Mat IMG2 = cv::imread("/home/tianru/temp/pic/_40.jpg", 1);
    cv::Mat img1 = IMG1.clone();
    cv::Mat img2 = IMG2.clone();
    img1.convertTo(img1, CV_8U);
    img2.convertTo(img2, CV_8U);

    cv::Ptr<cv::xfeatures2d::SURF> detector = cv::xfeatures2d::SURF::create(200);
    std::vector<cv::KeyPoint> keypoints1, keypoints2;
    detector->detect(img1, keypoints1, cv::Mat());
    detector->detect(img2, keypoints2, cv::Mat());

    cv::Ptr<cv::xfeatures2d::SurfDescriptorExtractor> surfDesc = cv::xfeatures2d::SurfDescriptorExtractor::create();
    surfDesc->compute(img1, keypoints1, img1);
    surfDesc->compute(img2, keypoints2, img2);

    cv::Ptr<cv::FlannBasedMatcher> matcher = cv::FlannBasedMatcher::create();
    std::vector<std::vector<cv::DMatch>> matchePoints;
    std::vector<cv::DMatch> GoodMatchePoints;

    std::vector<cv::Mat> train_desc(1, img1);
    matcher->add(train_desc);
    matcher->train();

    matcher->knnMatch(img2, matchePoints, 2);

    for (int i = 0; i < matchePoints.size(); i++) {
        if (matchePoints[i][0].distance < 0.6 * matchePoints[i][1].distance)
            GoodMatchePoints.push_back(matchePoints[i][0]);
    }

    cv::Mat first_match;
    std::cout << GoodMatchePoints.size() << std::endl;
    cv::drawMatches(IMG2, keypoints2, IMG1, keypoints1, GoodMatchePoints,first_match);
    cv::imshow("3", first_match);
}
```
<img src='/pic/002.jpg' width='600'/>

## 19 绘制点、线、文字
```cpp
#include "stdafx.h"
#include <iostream>
#include <string.h>
#include <opencv2\opencv.hpp>
using namespace cv;
using namespace std;
int main()
{
 
	Mat src = imread("images/2.jpg");//图片必须添加到工程目录下
 
	// 将原图像转换为灰度图像    
	//cvtColor(src, src, CV_BGR2GRAY)
 
	//在原图画一个圆圈点
	cv::Point point;//特征点，用以画在图像中  
	point.x = 20;//特征点在图像中横坐标  
	point.y = 50;//特征点在图像中纵坐标  
	cv::circle(src, point, 4, cv::Scalar(0, 0, 255));//在图像中画出特征点，2是圆的半径 
 
	//在原图画一条直线
	cv::Point start = cv::Point(10, 100); //直线起点
	cv::Point end = cv::Point(50, 200);   //直线终点
	cv::line(src, start, end, cv::Scalar(0, 0, 255));
 
	//在原图某个位置添加文字标记
	//char str[4];
	//int num = 100;
	//_itoa_s(num, str, 10);//数字需要转为字符串来显示
	string str = "Love100";
	putText(src, str, end, cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(0, 255,0 ), 2);
	imshow("src", src);
	waitKey(0);
}
```

## 20 goodFeaturesToTrack寻找角点
```cpp
int main()
{
    cv::Mat IMG1 = cv::imread("0.jpg", 1);
    cv::Mat img1 = IMG1.clone();
    cv::cvtColor(img1, img1, cv::COLOR_BGR2GRAY);
    img1.convertTo(img1, CV_32FC1);

    std::vector<cv::Point2f> prev_pts, curr_pts;
    cv::goodFeaturesToTrack(img1,prev_pts,100, 0.01, 20);
    for (int i = 0; i < prev_pts.size(); i++) {
        cv::circle(IMG1, prev_pts[i], 3, cv::Scalar(i*255/prev_pts.size(), //  绘制特征点
                                                    255-i*255/prev_pts.size(), 0), -1);
    }
    cv::imshow("1", IMG1);
}
```
## 21 视频稳定的方法
[参考](https://blog.csdn.net/LuohenYJ/article/details/88355444)

## 22 保存无损图片
```cpp
	std::vector<int> compression_params;
	compression_params.push_back(CV_IMWRITE_JPEG_QUALITY);
	compression_params.push_back(100);//这里的参数100表示不压缩，100%原图
	cv::imwrite("...", img, compression_params);
```
## 23 裁剪图片
```c
cv::Mat frame = cv::imread("0.jpg", 1);
frame = frame(cv::Rect(X, Y, W, H)); // X、Y、W、H 分别为左上角坐标x、y、宽度、高度
```

## row、col和x、y

- rows:表示图像有多少行
- cols: 表示图像有多少列
- heigh: 高度
- width: 宽度
  
关系：
```cpp
rows == heigh == Point.y
cols == width == Point.x
Mat::at(Point(x, y)) == Mat::at(y,x)
```


