---
title: cplus_learn
date: 2020-08-28 15:50:43
permalink: /pages/49b2e8/
categories: 
  - 编程语言
  - C++
tags: 
  - c++
---

## 0 注释

- 文件首部
```cpp
/*!
* \file Ctext.h
* \brief 概述 
* 
*详细概述 
* 
* \author 作者名字
* \version 版本号(maj.min，主版本.分版本格式) 
* \date 日期 
```

- 命名空间
```cpp
/** @brief 命名空间的简单概述 
 *
 * 命名空间的详细概述
 */
namespace text
{
}
```

- 类
```cpp
/** @brief Ctext的doxygen测试
 *
 * 作doxygen测试用
 * @code
    Ctext a;
 * @endcode
 * @note 注意事项
 */
class Ctext
{
}
```

- 函数
```cpp
/** @brief 函数名字说明
 *
 * 详细说明
 * @param p1 参数1
 * @param p2 参数2
 * @return 返回值
 * @example /src/test.cpp
 * @cite 引用
 * @note 注意事项
 */
void fun(int p1, int p2) {
    return p1 + p2;
}
```


## 1 文件操作

根据文件的读写方式，分为了这三种文件数据类型：

| 数据类型 | 描述 |
|--|--|
|ofstream|输出文件流，可以创建文件，并向文件写信息|
|ifstream|输入文件流，从文件读信息|
|fstream|有上面的两种功能|

### 1.1 打开/关闭文件
打开文件用于写：
```c
// ofstream f(); // 打开文件
ofstream f
f.open("xxx.txt", ios::out | ios::trunc);

f.close(); // 关闭文件
```
打开文件时有两个参数，第一个是文件路径名称，第二个是打开的模式，有以下几种：

|模式标志|描述|
|--|--|
|ios::app|追加模式|
|ios::ate|文件打开后定位到文件末尾|
|ios::in|读文件|
|ios::out|写文件|
|ios::trunc|如果该文件已经存在，打开时把文件长度设为0，相当于重写文件|


### 1.2 读文件
采用流提取运算符 `>>`，如：
```c
ifstream f("xxx.txt");
f >> data; // data可以是int、string等
f.close();
```
### 1.3 写文件
采用流提取运算符 `<<`
```c
ofstream f("xxx.txt");
f << data; // data可以是int、string等
f.close();
```
### 1.4 文件指针
1) 定位文件指针
file.seekg(c_num, mode)
参数1：c_num 为字节数
参数2：mode有以下几种

|模式|说明|
|--|--|
|std:: ios::beg| 开头+偏移|
|std:: ios::cur| 当前+偏移|
|std:: ios::end| 末尾+偏移|

2) 读文件
```c
file.read(&变量， sizeof(变量))
```
3) 写文件
```c
file.write(&变量， sizeof(变量))
```
4) 判断文件末尾
```c
file.eof()  // 返回值为bool
```
5) 当前指针到文件起点的长度
```c
file.tellg()
```
## 2 虚函数
关于虚函数的重要概念：

-  定义为虚函数，不代表它不被实现，定义为纯虚函数，才代表它没有被实现
-  定义为虚函数是为了允许用基类的指针来调用子类的这个函数
-  定义纯虚函数是为了实现一个接口，继承这个类时必须要实现这个函数

### 2.1 举例
以下代码验证了上面的第二点：
```c
class A
{
    public:
        virtual void foo() {cout<<"A::foo() is called"<<endl;     }
}; 
class B:public A{public:
    void foo(){cout<<"B::foo() is called"<<endl;}
}; 
int main(void)
{
    A *a = new B();
    a->foo();
        // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!
    return 0;
}
```
### 2.2 纯虚函数
纯虚函数是在基类中声明的虚函数，并且在基类中没有定义，但是要求任何派生类都要定义自己的实现方法；在基类中实现虚函数的方法是在虚函数原型后面加`=0`；
```c
virtual void function_1()=0;
```
含有纯虚函数的类称为抽象类，一般也是作为基类使用，它不能实例化，如果派生类里实现了这个函数，才能实例化这个派生类的实例，如果派生类里也没有实现那么也不能实例化；
## 3 命名空间
命名控件主要是定义某个区间内的函数或类，避免这些函数名与其他库的函数名冲突；下面的例子展示了命名空间的定义和调用，不过调用时建议不使用`using namespace`关键字，直接使用命名空间的全路径，比如：first_space::func()；
```c
#include <iostream>
// first name space
namespace first_space{
void func(){
    std::cout << "Inside first_space" << std::endl;
}
}
// second name space
namespace second_space{
//此处func与第一处命名空间内函数名相同
void func(){
    std::cout << "Inside second_space" << std::endl;
}
}
// 使用第一个namespace
using namespace first_space;
int main () {
    // This calls function from first name space.
    func();
    return 0;
}
```

## 4 template
template表示模板，模板里的变量类型在函数被调用的时候才指定；模板分为函数模板和类模板；
### 4.1 函数模板
函数模板的定义形式如下：
```c
template <class type> ret-type func-name(parameter list)
{
    // 函数内容
}
```
以上代码中的type是个占位符，表示数据类型，这个数据类型的名称有外部传入；
实例：
```c
#include <iostream> 
#include <string>
using namespace std; 
template <typename T> 
inline T const& Max (T const& a, T const& b)
{
    return a < b ? b:a; 
}
int main ()
{
    int i = 39; 
    int j = 20; 
    cout << "Max(i, j): " << Max(i, j) << endl; 
    double f1 = 13.5; 
    double f2 = 20.7; 
    cout << "Max(f1, f2): " << Max(f1, f2) << endl; 
    string s1 = "Hello"; 
    string s2 = "World"; 
    cout << "Max(s1, s2): " << Max(s1, s2) << endl; 
    return 0; 
}
```
### 4.2 类模板
类模板的定义形式如下：
```c
template <class type> class class-name {
}
```
实例：
```c
#include <iostream> 
#include <vector> 
#include <cstdlib> 
#include <string>
#include <stdexcept>
using namespace std; 
template <class T> 
class Stack {
    private: vector<T> elems;  // 元素 
    public: void push(T const&);  // 入栈
    void pop(); // 出栈
    T top() const;  // 返回栈顶元素
    bool empty() const{  // 如果为空则返回真。
        return elems.empty(); 
    }
}; 

template <class T> 
void Stack<T>::push (T const& elem)
{
    // 追加传入元素的副本
    elems.push_back(elem);
}

template <class T> 
void Stack<T>::pop ()
{
    if (elems.empty())  {
        throw out_of_range("Stack<>::pop(): empty stack"); 
    }
    // 删除最后一个元素
    elems.pop_back(); 
}

template <class T> 
T Stack<T>::top () const
{
    if (elems.empty()) {
        throw out_of_range("Stack<>::top(): empty stack"); 
    }
// 返回最后一个元素的副本 
    return elems.back(); 
}

int main()
{
    try {
        Stack<int> intStack;  // int 类型的栈 
        Stack<string> stringStack;  // string 类型的栈 

        // 操作 int 类型的栈 
        intStack.push(7); 
        cout << intStack.top() <<endl;

        // 操作 string 类型的栈 
        stringStack.push("hello"); 
        cout << stringStack.top() << std::endl; stringStack.pop(); 
        stringStack.pop(); 
    }
    catch (exception const& ex) 
    {
        cerr << "Exception: " << ex.what() <<endl; return -1; 
    }
}
```

## 5 string 和 int 互换
```c
string s="123";
int a=atoi(s.c_str());

int i = 123;
std::string s = std::to_string(i);
```
## 6 数据结构
可以参考[这里](http://c.biancheng.net/view/418.html)
或者[这里](http://www.cplusplus.com/reference/deque/deque/begin/)
### 6.1 顺序存储结构
- 如果你需要高效的随即存取，而不在乎插入和删除的效率，使用`vector`；
- 如果你需要大量的插入和删除，而不关心随机存取，则应使用`list`；
- 如果你需要随机存取，而且关心两端数据的插入和删除，则应使用`deque`；
#### 6.1.1 vector
1. 初始化
    ```c
   std::vector<int> d1; // 创建vector对象，有0个元素，存储类型为int（可以自定义类型，比如一个结构体）
   std::vector<int> d2(5); // 创建vector对象，有5个元素，元素初始值依赖编译器
   std::vector<int> d3(5, 10); // 创建vector对象，有5个元素，元素值为10
   std::vector<int> d4(d3); // d2是d1的副本，它们有自己的内存区域
   std::vector<int> d5(d3.begin(), d3.begin()+3); // 复制 d3[0] -- d3[3-1] 给d5初始化
    ```
2. 迭代器
	迭代器用于保存数据结构的索引，也可以用来访问数据，如：
    ```c
   std::vector<int>::iterator it;
   it = d5.begin();
   it++; // 迭代器可以做 +、- 操作
   std::cout << *it << std::endl; // 访问这个节点的值
    ```
    vector也可以像数组一样访问数据，如：d5[0]、d5[1]；
3. 函数
	```c
	d1.push_back(1); // 在尾部追加数据
	d1.insert(d1.begin()+1, 10); // 在索引1处插入数据10
	d1.pop_back(); // 删除尾部数据
	d1.erase(d1.begin()+1, d1.begin()+3); // 删除 d1[1] -- d1[3-1] 的数据
	d1.clear(); // 清空数据
	d1.size(); // 当前vector的长度
	d1.capacity(); // 在重新分配容量之前的最大容量，如果数据超过这个值，才会重新分配
	```

#### 6.1.2 list
1. 初始化
	```c
	list<int> lst1; //创建空list
    list<int> lst2(5); //创建含有5个元素的list
    list<int> lst3(3,2); //创建含有3个元素的list
    list<int> lst4(lst2); //使用lst2初始化lst4
    list<int> lst5(lst2.begin(),lst2.end());  //同lst4
	```
2. 迭代器
	```c
	std::list<int>::iterator it;
	```
	可以用于遍历list：
	```c
	for (std::list<int>::iterator it = lst1.begin(); it != lst1.end(); ++it)
		std::cout << *it << std::endl;
	```
  注：list中的迭代器只能使用++、- -的操作，不能直接+2、+3等；
4. 函数
	```c
	lst1.assign(3, 10) //给list赋值，这里是分配3个元素，值都为10
	lst1.resize(3) //改变list的大小，这里会只保留前面3个数据，如果3比原来的元素多，那么差的元素补0
	
	// 对迭代器的操作
	lst1.begin() //返回第一个元素的迭代器
	lst1.end() //返回最后一个元素的迭代器
	
	// 对元素的操作
	lst1.push_back() //在末尾添加一个元素
	lst1.push_front() //在头部添加一个元素
	lst1.insert(lst1.begin(), 10) //插入一个元素到list中，这里是在头部插入一个元素，值为10
	lst1.pop_back() //删除最后一个元素
	lst1.pop_front() //删除第一个元素
	lst1.erase(lst1.begin()) //删除一个元素，这里是删除第一个元素
	lst1.clear() //删除所有元素
	lst1.remove(10) //从list中删除值为10的所有元素
	lst1.front() //返回第一个元素
	lst1.back() //返回最后一个元素
	
	// 读取信息
	lst1.size() //返回list中的元素个数
	lst1.empty() //如果list是空的则返回true
	lst1.max_size() //返回list能容纳的最大元素数量
	
	// 对list的操作
	lst1.merge(lst2) //把lst2合并到lst1的末尾
	lst1.splice(++lst1.begin(), lst2) // 把lst2插入到lst1的指定位置，第一参数描述的插入位置
	lst1.reverse() //把list的元素倒转
	lst1.sort() //给list排序，在int类型中可以使用，自定义的数据类型不能用
	lst1.swap(lst2) //交换两个list
	lst1.unique() //删除list中重复的元素
	//lst1.get_allocator() //返回list的配置器
	//lst1.remove_if() //按指定条件删除元素
	//lst1.rbegin() //返回指向第一个元素的逆向迭代器
	//lst1.rend() //指向list末尾的逆向迭代器
	```
#### 6.1.3 deque

### 6.2 关联存储结构
#### 6.2.1 set
#### 6.2.2 map
#### 6.2.3 multiset
## 7 智能指针
参考[这里](https://cloud.tencent.com/developer/article/1496722)


